<!DOCTYPE HTML>
<html lang>
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: org.apache.commons.compress.utils, class: ArchiveUtils">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> * Licensed to the Apache Software Foundation (ASF) under one or more</span>
<span class="source-line-no">003</span><span id="line-3"> * contributor license agreements.  See the NOTICE file distributed with</span>
<span class="source-line-no">004</span><span id="line-4"> * this work for additional information regarding copyright ownership.</span>
<span class="source-line-no">005</span><span id="line-5"> * The ASF licenses this file to You under the Apache License, Version 2.0</span>
<span class="source-line-no">006</span><span id="line-6"> * (the "License"); you may not use this file except in compliance with</span>
<span class="source-line-no">007</span><span id="line-7"> * the License.  You may obtain a copy of the License at</span>
<span class="source-line-no">008</span><span id="line-8"> *</span>
<span class="source-line-no">009</span><span id="line-9"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">010</span><span id="line-10"> *</span>
<span class="source-line-no">011</span><span id="line-11"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">012</span><span id="line-12"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">013</span><span id="line-13"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">014</span><span id="line-14"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">015</span><span id="line-15"> * limitations under the License.</span>
<span class="source-line-no">016</span><span id="line-16"> */</span>
<span class="source-line-no">017</span><span id="line-17"></span>
<span class="source-line-no">018</span><span id="line-18">package org.apache.commons.compress.utils;</span>
<span class="source-line-no">019</span><span id="line-19"></span>
<span class="source-line-no">020</span><span id="line-20">import static java.nio.charset.StandardCharsets.US_ASCII;</span>
<span class="source-line-no">021</span><span id="line-21"></span>
<span class="source-line-no">022</span><span id="line-22">import java.util.Arrays;</span>
<span class="source-line-no">023</span><span id="line-23"></span>
<span class="source-line-no">024</span><span id="line-24">import org.apache.commons.compress.archivers.ArchiveEntry;</span>
<span class="source-line-no">025</span><span id="line-25"></span>
<span class="source-line-no">026</span><span id="line-26">/**</span>
<span class="source-line-no">027</span><span id="line-27"> * Generic Archive utilities</span>
<span class="source-line-no">028</span><span id="line-28"> */</span>
<span class="source-line-no">029</span><span id="line-29">public class ArchiveUtils {</span>
<span class="source-line-no">030</span><span id="line-30"></span>
<span class="source-line-no">031</span><span id="line-31">    private static final int MAX_SANITIZED_NAME_LENGTH = 255;</span>
<span class="source-line-no">032</span><span id="line-32"></span>
<span class="source-line-no">033</span><span id="line-33">    /**</span>
<span class="source-line-no">034</span><span id="line-34">     * Returns true if the first N bytes of an array are all zero</span>
<span class="source-line-no">035</span><span id="line-35">     *</span>
<span class="source-line-no">036</span><span id="line-36">     * @param a    The array to check</span>
<span class="source-line-no">037</span><span id="line-37">     * @param size The number of characters to check (not the size of the array)</span>
<span class="source-line-no">038</span><span id="line-38">     * @return true if the first N bytes are zero</span>
<span class="source-line-no">039</span><span id="line-39">     */</span>
<span class="source-line-no">040</span><span id="line-40">    public static boolean isArrayZero(final byte[] a, final int size) {</span>
<span class="source-line-no">041</span><span id="line-41">        for (int i = 0; i &lt; size; i++) {</span>
<span class="source-line-no">042</span><span id="line-42">            if (a[i] != 0) {</span>
<span class="source-line-no">043</span><span id="line-43">                return false;</span>
<span class="source-line-no">044</span><span id="line-44">            }</span>
<span class="source-line-no">045</span><span id="line-45">        }</span>
<span class="source-line-no">046</span><span id="line-46">        return true;</span>
<span class="source-line-no">047</span><span id="line-47">    }</span>
<span class="source-line-no">048</span><span id="line-48"></span>
<span class="source-line-no">049</span><span id="line-49">    /**</span>
<span class="source-line-no">050</span><span id="line-50">     * Compare byte buffers</span>
<span class="source-line-no">051</span><span id="line-51">     *</span>
<span class="source-line-no">052</span><span id="line-52">     * @param buffer1 the first buffer</span>
<span class="source-line-no">053</span><span id="line-53">     * @param buffer2 the second buffer</span>
<span class="source-line-no">054</span><span id="line-54">     * @return {@code true} if buffer1 and buffer2 have same contents</span>
<span class="source-line-no">055</span><span id="line-55">     * @deprecated Use {@link Arrays#equals(byte[], byte[])}.</span>
<span class="source-line-no">056</span><span id="line-56">     */</span>
<span class="source-line-no">057</span><span id="line-57">    @Deprecated</span>
<span class="source-line-no">058</span><span id="line-58">    public static boolean isEqual(final byte[] buffer1, final byte[] buffer2) {</span>
<span class="source-line-no">059</span><span id="line-59">        return Arrays.equals(buffer1, buffer2);</span>
<span class="source-line-no">060</span><span id="line-60">    }</span>
<span class="source-line-no">061</span><span id="line-61"></span>
<span class="source-line-no">062</span><span id="line-62">    /**</span>
<span class="source-line-no">063</span><span id="line-63">     * Compare byte buffers, optionally ignoring trailing nulls</span>
<span class="source-line-no">064</span><span id="line-64">     *</span>
<span class="source-line-no">065</span><span id="line-65">     * @param buffer1             the first buffer</span>
<span class="source-line-no">066</span><span id="line-66">     * @param buffer2             the second buffer</span>
<span class="source-line-no">067</span><span id="line-67">     * @param ignoreTrailingNulls whether to ignore trailing nulls</span>
<span class="source-line-no">068</span><span id="line-68">     * @return {@code true} if buffer1 and buffer2 have same contents</span>
<span class="source-line-no">069</span><span id="line-69">     */</span>
<span class="source-line-no">070</span><span id="line-70">    public static boolean isEqual(final byte[] buffer1, final byte[] buffer2, final boolean ignoreTrailingNulls) {</span>
<span class="source-line-no">071</span><span id="line-71">        return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, ignoreTrailingNulls);</span>
<span class="source-line-no">072</span><span id="line-72">    }</span>
<span class="source-line-no">073</span><span id="line-73"></span>
<span class="source-line-no">074</span><span id="line-74">    /**</span>
<span class="source-line-no">075</span><span id="line-75">     * Compare byte buffers</span>
<span class="source-line-no">076</span><span id="line-76">     *</span>
<span class="source-line-no">077</span><span id="line-77">     * @param buffer1 the first buffer</span>
<span class="source-line-no">078</span><span id="line-78">     * @param offset1 the first offset</span>
<span class="source-line-no">079</span><span id="line-79">     * @param length1 the first length</span>
<span class="source-line-no">080</span><span id="line-80">     * @param buffer2 the second buffer</span>
<span class="source-line-no">081</span><span id="line-81">     * @param offset2 the second offset</span>
<span class="source-line-no">082</span><span id="line-82">     * @param length2 the second length</span>
<span class="source-line-no">083</span><span id="line-83">     * @return {@code true} if buffer1 and buffer2 have same contents</span>
<span class="source-line-no">084</span><span id="line-84">     */</span>
<span class="source-line-no">085</span><span id="line-85">    public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {</span>
<span class="source-line-no">086</span><span id="line-86">        return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, false);</span>
<span class="source-line-no">087</span><span id="line-87">    }</span>
<span class="source-line-no">088</span><span id="line-88"></span>
<span class="source-line-no">089</span><span id="line-89">    /**</span>
<span class="source-line-no">090</span><span id="line-90">     * Compare byte buffers, optionally ignoring trailing nulls</span>
<span class="source-line-no">091</span><span id="line-91">     *</span>
<span class="source-line-no">092</span><span id="line-92">     * @param buffer1             first buffer</span>
<span class="source-line-no">093</span><span id="line-93">     * @param offset1             first offset</span>
<span class="source-line-no">094</span><span id="line-94">     * @param length1             first length</span>
<span class="source-line-no">095</span><span id="line-95">     * @param buffer2             second buffer</span>
<span class="source-line-no">096</span><span id="line-96">     * @param offset2             second offset</span>
<span class="source-line-no">097</span><span id="line-97">     * @param length2             second length</span>
<span class="source-line-no">098</span><span id="line-98">     * @param ignoreTrailingNulls whether to ignore trailing nulls</span>
<span class="source-line-no">099</span><span id="line-99">     * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls</span>
<span class="source-line-no">100</span><span id="line-100">     */</span>
<span class="source-line-no">101</span><span id="line-101">    public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2,</span>
<span class="source-line-no">102</span><span id="line-102">            final boolean ignoreTrailingNulls) {</span>
<span class="source-line-no">103</span><span id="line-103">        final int minLen = Math.min(length1, length2);</span>
<span class="source-line-no">104</span><span id="line-104">        for (int i = 0; i &lt; minLen; i++) {</span>
<span class="source-line-no">105</span><span id="line-105">            if (buffer1[offset1 + i] != buffer2[offset2 + i]) {</span>
<span class="source-line-no">106</span><span id="line-106">                return false;</span>
<span class="source-line-no">107</span><span id="line-107">            }</span>
<span class="source-line-no">108</span><span id="line-108">        }</span>
<span class="source-line-no">109</span><span id="line-109">        if (length1 == length2) {</span>
<span class="source-line-no">110</span><span id="line-110">            return true;</span>
<span class="source-line-no">111</span><span id="line-111">        }</span>
<span class="source-line-no">112</span><span id="line-112">        if (ignoreTrailingNulls) {</span>
<span class="source-line-no">113</span><span id="line-113">            if (length1 &gt; length2) {</span>
<span class="source-line-no">114</span><span id="line-114">                for (int i = length2; i &lt; length1; i++) {</span>
<span class="source-line-no">115</span><span id="line-115">                    if (buffer1[offset1 + i] != 0) {</span>
<span class="source-line-no">116</span><span id="line-116">                        return false;</span>
<span class="source-line-no">117</span><span id="line-117">                    }</span>
<span class="source-line-no">118</span><span id="line-118">                }</span>
<span class="source-line-no">119</span><span id="line-119">            } else {</span>
<span class="source-line-no">120</span><span id="line-120">                for (int i = length1; i &lt; length2; i++) {</span>
<span class="source-line-no">121</span><span id="line-121">                    if (buffer2[offset2 + i] != 0) {</span>
<span class="source-line-no">122</span><span id="line-122">                        return false;</span>
<span class="source-line-no">123</span><span id="line-123">                    }</span>
<span class="source-line-no">124</span><span id="line-124">                }</span>
<span class="source-line-no">125</span><span id="line-125">            }</span>
<span class="source-line-no">126</span><span id="line-126">            return true;</span>
<span class="source-line-no">127</span><span id="line-127">        }</span>
<span class="source-line-no">128</span><span id="line-128">        return false;</span>
<span class="source-line-no">129</span><span id="line-129">    }</span>
<span class="source-line-no">130</span><span id="line-130"></span>
<span class="source-line-no">131</span><span id="line-131">    /**</span>
<span class="source-line-no">132</span><span id="line-132">     * Compare byte buffers, ignoring trailing nulls</span>
<span class="source-line-no">133</span><span id="line-133">     *</span>
<span class="source-line-no">134</span><span id="line-134">     * @param buffer1 the first buffer</span>
<span class="source-line-no">135</span><span id="line-135">     * @param offset1 the first offset</span>
<span class="source-line-no">136</span><span id="line-136">     * @param length1 the first length</span>
<span class="source-line-no">137</span><span id="line-137">     * @param buffer2 the second buffer</span>
<span class="source-line-no">138</span><span id="line-138">     * @param offset2 the second offset</span>
<span class="source-line-no">139</span><span id="line-139">     * @param length2 the second length</span>
<span class="source-line-no">140</span><span id="line-140">     * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls</span>
<span class="source-line-no">141</span><span id="line-141">     */</span>
<span class="source-line-no">142</span><span id="line-142">    public static boolean isEqualWithNull(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2,</span>
<span class="source-line-no">143</span><span id="line-143">            final int length2) {</span>
<span class="source-line-no">144</span><span id="line-144">        return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, true);</span>
<span class="source-line-no">145</span><span id="line-145">    }</span>
<span class="source-line-no">146</span><span id="line-146"></span>
<span class="source-line-no">147</span><span id="line-147">    /**</span>
<span class="source-line-no">148</span><span id="line-148">     * Check if buffer contents matches ASCII String.</span>
<span class="source-line-no">149</span><span id="line-149">     *</span>
<span class="source-line-no">150</span><span id="line-150">     * @param expected the expected string</span>
<span class="source-line-no">151</span><span id="line-151">     * @param buffer   the buffer</span>
<span class="source-line-no">152</span><span id="line-152">     * @return {@code true} if buffer is the same as the expected string</span>
<span class="source-line-no">153</span><span id="line-153">     */</span>
<span class="source-line-no">154</span><span id="line-154">    public static boolean matchAsciiBuffer(final String expected, final byte[] buffer) {</span>
<span class="source-line-no">155</span><span id="line-155">        return matchAsciiBuffer(expected, buffer, 0, buffer.length);</span>
<span class="source-line-no">156</span><span id="line-156">    }</span>
<span class="source-line-no">157</span><span id="line-157"></span>
<span class="source-line-no">158</span><span id="line-158">    /**</span>
<span class="source-line-no">159</span><span id="line-159">     * Check if buffer contents matches ASCII String.</span>
<span class="source-line-no">160</span><span id="line-160">     *</span>
<span class="source-line-no">161</span><span id="line-161">     * @param expected expected string</span>
<span class="source-line-no">162</span><span id="line-162">     * @param buffer   the buffer</span>
<span class="source-line-no">163</span><span id="line-163">     * @param offset   offset to read from</span>
<span class="source-line-no">164</span><span id="line-164">     * @param length   length of the buffer</span>
<span class="source-line-no">165</span><span id="line-165">     * @return {@code true} if buffer is the same as the expected string</span>
<span class="source-line-no">166</span><span id="line-166">     */</span>
<span class="source-line-no">167</span><span id="line-167">    public static boolean matchAsciiBuffer(final String expected, final byte[] buffer, final int offset, final int length) {</span>
<span class="source-line-no">168</span><span id="line-168">        final byte[] buffer1;</span>
<span class="source-line-no">169</span><span id="line-169">        buffer1 = expected.getBytes(US_ASCII);</span>
<span class="source-line-no">170</span><span id="line-170">        return isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);</span>
<span class="source-line-no">171</span><span id="line-171">    }</span>
<span class="source-line-no">172</span><span id="line-172"></span>
<span class="source-line-no">173</span><span id="line-173">    /**</span>
<span class="source-line-no">174</span><span id="line-174">     * Returns a "sanitized" version of the string given as arguments, where sanitized means non-printable characters have been replaced with a question mark</span>
<span class="source-line-no">175</span><span id="line-175">     * and the outcome is not longer than 255 chars.</span>
<span class="source-line-no">176</span><span id="line-176">     *</span>
<span class="source-line-no">177</span><span id="line-177">     * &lt;p&gt;</span>
<span class="source-line-no">178</span><span id="line-178">     * This method is used to clean up file names when they are used in exception messages as they may end up in log files or as console output and may have</span>
<span class="source-line-no">179</span><span id="line-179">     * been read from a corrupted input.</span>
<span class="source-line-no">180</span><span id="line-180">     * &lt;/p&gt;</span>
<span class="source-line-no">181</span><span id="line-181">     *</span>
<span class="source-line-no">182</span><span id="line-182">     * @param s the string to sanitize</span>
<span class="source-line-no">183</span><span id="line-183">     * @return a sanitized version of the argument</span>
<span class="source-line-no">184</span><span id="line-184">     * @since 1.12</span>
<span class="source-line-no">185</span><span id="line-185">     */</span>
<span class="source-line-no">186</span><span id="line-186">    public static String sanitize(final String s) {</span>
<span class="source-line-no">187</span><span id="line-187">        final char[] cs = s.toCharArray();</span>
<span class="source-line-no">188</span><span id="line-188">        final char[] chars = cs.length &lt;= MAX_SANITIZED_NAME_LENGTH ? cs : Arrays.copyOf(cs, MAX_SANITIZED_NAME_LENGTH);</span>
<span class="source-line-no">189</span><span id="line-189">        if (cs.length &gt; MAX_SANITIZED_NAME_LENGTH) {</span>
<span class="source-line-no">190</span><span id="line-190">            Arrays.fill(chars, MAX_SANITIZED_NAME_LENGTH - 3, MAX_SANITIZED_NAME_LENGTH, '.');</span>
<span class="source-line-no">191</span><span id="line-191">        }</span>
<span class="source-line-no">192</span><span id="line-192">        final StringBuilder sb = new StringBuilder();</span>
<span class="source-line-no">193</span><span id="line-193">        for (final char c : chars) {</span>
<span class="source-line-no">194</span><span id="line-194">            if (!Character.isISOControl(c)) {</span>
<span class="source-line-no">195</span><span id="line-195">                final Character.UnicodeBlock block = Character.UnicodeBlock.of(c);</span>
<span class="source-line-no">196</span><span id="line-196">                if (block != null &amp;&amp; block != Character.UnicodeBlock.SPECIALS) {</span>
<span class="source-line-no">197</span><span id="line-197">                    sb.append(c);</span>
<span class="source-line-no">198</span><span id="line-198">                    continue;</span>
<span class="source-line-no">199</span><span id="line-199">                }</span>
<span class="source-line-no">200</span><span id="line-200">            }</span>
<span class="source-line-no">201</span><span id="line-201">            sb.append('?');</span>
<span class="source-line-no">202</span><span id="line-202">        }</span>
<span class="source-line-no">203</span><span id="line-203">        return sb.toString();</span>
<span class="source-line-no">204</span><span id="line-204">    }</span>
<span class="source-line-no">205</span><span id="line-205"></span>
<span class="source-line-no">206</span><span id="line-206">    /**</span>
<span class="source-line-no">207</span><span id="line-207">     * Convert a string to ASCII bytes. Used for comparing "magic" strings which need to be independent of the default Locale.</span>
<span class="source-line-no">208</span><span id="line-208">     *</span>
<span class="source-line-no">209</span><span id="line-209">     * @param inputString string to convert</span>
<span class="source-line-no">210</span><span id="line-210">     * @return the bytes</span>
<span class="source-line-no">211</span><span id="line-211">     */</span>
<span class="source-line-no">212</span><span id="line-212">    public static byte[] toAsciiBytes(final String inputString) {</span>
<span class="source-line-no">213</span><span id="line-213">        return inputString.getBytes(US_ASCII);</span>
<span class="source-line-no">214</span><span id="line-214">    }</span>
<span class="source-line-no">215</span><span id="line-215"></span>
<span class="source-line-no">216</span><span id="line-216">    /**</span>
<span class="source-line-no">217</span><span id="line-217">     * Convert an input byte array to a String using the ASCII character set.</span>
<span class="source-line-no">218</span><span id="line-218">     *</span>
<span class="source-line-no">219</span><span id="line-219">     * @param inputBytes bytes to convert</span>
<span class="source-line-no">220</span><span id="line-220">     * @return the bytes, interpreted as an ASCII string</span>
<span class="source-line-no">221</span><span id="line-221">     */</span>
<span class="source-line-no">222</span><span id="line-222">    public static String toAsciiString(final byte[] inputBytes) {</span>
<span class="source-line-no">223</span><span id="line-223">        return new String(inputBytes, US_ASCII);</span>
<span class="source-line-no">224</span><span id="line-224">    }</span>
<span class="source-line-no">225</span><span id="line-225"></span>
<span class="source-line-no">226</span><span id="line-226">    /**</span>
<span class="source-line-no">227</span><span id="line-227">     * Convert an input byte array to a String using the ASCII character set.</span>
<span class="source-line-no">228</span><span id="line-228">     *</span>
<span class="source-line-no">229</span><span id="line-229">     * @param inputBytes input byte array</span>
<span class="source-line-no">230</span><span id="line-230">     * @param offset     offset within array</span>
<span class="source-line-no">231</span><span id="line-231">     * @param length     length of array</span>
<span class="source-line-no">232</span><span id="line-232">     * @return the bytes, interpreted as an ASCII string</span>
<span class="source-line-no">233</span><span id="line-233">     */</span>
<span class="source-line-no">234</span><span id="line-234">    public static String toAsciiString(final byte[] inputBytes, final int offset, final int length) {</span>
<span class="source-line-no">235</span><span id="line-235">        return new String(inputBytes, offset, length, US_ASCII);</span>
<span class="source-line-no">236</span><span id="line-236">    }</span>
<span class="source-line-no">237</span><span id="line-237"></span>
<span class="source-line-no">238</span><span id="line-238">    /**</span>
<span class="source-line-no">239</span><span id="line-239">     * Generates a string containing the name, isDirectory setting and size of an entry.</span>
<span class="source-line-no">240</span><span id="line-240">     * &lt;p&gt;</span>
<span class="source-line-no">241</span><span id="line-241">     * For example:</span>
<span class="source-line-no">242</span><span id="line-242">     *</span>
<span class="source-line-no">243</span><span id="line-243">     * &lt;pre&gt;</span>
<span class="source-line-no">244</span><span id="line-244">     * -    2000 main.c</span>
<span class="source-line-no">245</span><span id="line-245">     * d     100 testfiles</span>
<span class="source-line-no">246</span><span id="line-246">     * &lt;/pre&gt;</span>
<span class="source-line-no">247</span><span id="line-247">     *</span>
<span class="source-line-no">248</span><span id="line-248">     * @param entry the entry</span>
<span class="source-line-no">249</span><span id="line-249">     * @return the representation of the entry</span>
<span class="source-line-no">250</span><span id="line-250">     */</span>
<span class="source-line-no">251</span><span id="line-251">    public static String toString(final ArchiveEntry entry) {</span>
<span class="source-line-no">252</span><span id="line-252">        final StringBuilder sb = new StringBuilder();</span>
<span class="source-line-no">253</span><span id="line-253">        sb.append(entry.isDirectory() ? 'd' : '-'); // c.f. "ls -l" output</span>
<span class="source-line-no">254</span><span id="line-254">        final String size = Long.toString(entry.getSize());</span>
<span class="source-line-no">255</span><span id="line-255">        sb.append(' ');</span>
<span class="source-line-no">256</span><span id="line-256">        // Pad output to 7 places, leading spaces</span>
<span class="source-line-no">257</span><span id="line-257">        for (int i = 7; i &gt; size.length(); i--) {</span>
<span class="source-line-no">258</span><span id="line-258">            sb.append(' ');</span>
<span class="source-line-no">259</span><span id="line-259">        }</span>
<span class="source-line-no">260</span><span id="line-260">        sb.append(size);</span>
<span class="source-line-no">261</span><span id="line-261">        sb.append(' ').append(entry.getName());</span>
<span class="source-line-no">262</span><span id="line-262">        return sb.toString();</span>
<span class="source-line-no">263</span><span id="line-263">    }</span>
<span class="source-line-no">264</span><span id="line-264"></span>
<span class="source-line-no">265</span><span id="line-265">    /** Private constructor to prevent instantiation of this utility class. */</span>
<span class="source-line-no">266</span><span id="line-266">    private ArchiveUtils() {</span>
<span class="source-line-no">267</span><span id="line-267">    }</span>
<span class="source-line-no">268</span><span id="line-268"></span>
<span class="source-line-no">269</span><span id="line-269">}</span>




























































</pre>
</div>
</main>
</body>
</html>
