<!DOCTYPE HTML>
<html lang>
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: org.apache.commons.compress.archivers.tar, class: TarFile">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> *  Licensed to the Apache Software Foundation (ASF) under one or more</span>
<span class="source-line-no">003</span><span id="line-3"> *  contributor license agreements.  See the NOTICE file distributed with</span>
<span class="source-line-no">004</span><span id="line-4"> *  this work for additional information regarding copyright ownership.</span>
<span class="source-line-no">005</span><span id="line-5"> *  The ASF licenses this file to You under the Apache License, Version 2.0</span>
<span class="source-line-no">006</span><span id="line-6"> *  (the "License"); you may not use this file except in compliance with</span>
<span class="source-line-no">007</span><span id="line-7"> *  the License.  You may obtain a copy of the License at</span>
<span class="source-line-no">008</span><span id="line-8"> *</span>
<span class="source-line-no">009</span><span id="line-9"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">010</span><span id="line-10"> *</span>
<span class="source-line-no">011</span><span id="line-11"> *  Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">012</span><span id="line-12"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">013</span><span id="line-13"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">014</span><span id="line-14"> *  See the License for the specific language governing permissions and</span>
<span class="source-line-no">015</span><span id="line-15"> *  limitations under the License.</span>
<span class="source-line-no">016</span><span id="line-16"> */</span>
<span class="source-line-no">017</span><span id="line-17">package org.apache.commons.compress.archivers.tar;</span>
<span class="source-line-no">018</span><span id="line-18"></span>
<span class="source-line-no">019</span><span id="line-19">import java.io.ByteArrayOutputStream;</span>
<span class="source-line-no">020</span><span id="line-20">import java.io.Closeable;</span>
<span class="source-line-no">021</span><span id="line-21">import java.io.File;</span>
<span class="source-line-no">022</span><span id="line-22">import java.io.IOException;</span>
<span class="source-line-no">023</span><span id="line-23">import java.io.InputStream;</span>
<span class="source-line-no">024</span><span id="line-24">import java.nio.ByteBuffer;</span>
<span class="source-line-no">025</span><span id="line-25">import java.nio.channels.SeekableByteChannel;</span>
<span class="source-line-no">026</span><span id="line-26">import java.nio.file.Files;</span>
<span class="source-line-no">027</span><span id="line-27">import java.nio.file.Path;</span>
<span class="source-line-no">028</span><span id="line-28">import java.util.ArrayList;</span>
<span class="source-line-no">029</span><span id="line-29">import java.util.Arrays;</span>
<span class="source-line-no">030</span><span id="line-30">import java.util.HashMap;</span>
<span class="source-line-no">031</span><span id="line-31">import java.util.LinkedList;</span>
<span class="source-line-no">032</span><span id="line-32">import java.util.List;</span>
<span class="source-line-no">033</span><span id="line-33">import java.util.Map;</span>
<span class="source-line-no">034</span><span id="line-34"></span>
<span class="source-line-no">035</span><span id="line-35">import org.apache.commons.compress.archivers.zip.ZipEncoding;</span>
<span class="source-line-no">036</span><span id="line-36">import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;</span>
<span class="source-line-no">037</span><span id="line-37">import org.apache.commons.compress.utils.ArchiveUtils;</span>
<span class="source-line-no">038</span><span id="line-38">import org.apache.commons.compress.utils.BoundedArchiveInputStream;</span>
<span class="source-line-no">039</span><span id="line-39">import org.apache.commons.compress.utils.BoundedInputStream;</span>
<span class="source-line-no">040</span><span id="line-40">import org.apache.commons.compress.utils.BoundedSeekableByteChannelInputStream;</span>
<span class="source-line-no">041</span><span id="line-41">import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;</span>
<span class="source-line-no">042</span><span id="line-42"></span>
<span class="source-line-no">043</span><span id="line-43">/**</span>
<span class="source-line-no">044</span><span id="line-44"> * Provides random access to UNIX archives.</span>
<span class="source-line-no">045</span><span id="line-45"> *</span>
<span class="source-line-no">046</span><span id="line-46"> * @since 1.21</span>
<span class="source-line-no">047</span><span id="line-47"> */</span>
<span class="source-line-no">048</span><span id="line-48">public class TarFile implements Closeable {</span>
<span class="source-line-no">049</span><span id="line-49"></span>
<span class="source-line-no">050</span><span id="line-50">    private final class BoundedTarEntryInputStream extends BoundedArchiveInputStream {</span>
<span class="source-line-no">051</span><span id="line-51"></span>
<span class="source-line-no">052</span><span id="line-52">        private final SeekableByteChannel channel;</span>
<span class="source-line-no">053</span><span id="line-53"></span>
<span class="source-line-no">054</span><span id="line-54">        private final TarArchiveEntry entry;</span>
<span class="source-line-no">055</span><span id="line-55"></span>
<span class="source-line-no">056</span><span id="line-56">        private long entryOffset;</span>
<span class="source-line-no">057</span><span id="line-57"></span>
<span class="source-line-no">058</span><span id="line-58">        private int currentSparseInputStreamIndex;</span>
<span class="source-line-no">059</span><span id="line-59"></span>
<span class="source-line-no">060</span><span id="line-60">        BoundedTarEntryInputStream(final TarArchiveEntry entry, final SeekableByteChannel channel) throws IOException {</span>
<span class="source-line-no">061</span><span id="line-61">            super(entry.getDataOffset(), entry.getRealSize());</span>
<span class="source-line-no">062</span><span id="line-62">            if (channel.size() - entry.getSize() &lt; entry.getDataOffset()) {</span>
<span class="source-line-no">063</span><span id="line-63">                throw new IOException("entry size exceeds archive size");</span>
<span class="source-line-no">064</span><span id="line-64">            }</span>
<span class="source-line-no">065</span><span id="line-65">            this.entry = entry;</span>
<span class="source-line-no">066</span><span id="line-66">            this.channel = channel;</span>
<span class="source-line-no">067</span><span id="line-67">        }</span>
<span class="source-line-no">068</span><span id="line-68"></span>
<span class="source-line-no">069</span><span id="line-69">        @Override</span>
<span class="source-line-no">070</span><span id="line-70">        protected int read(final long pos, final ByteBuffer buf) throws IOException {</span>
<span class="source-line-no">071</span><span id="line-71">            if (entryOffset &gt;= entry.getRealSize()) {</span>
<span class="source-line-no">072</span><span id="line-72">                return -1;</span>
<span class="source-line-no">073</span><span id="line-73">            }</span>
<span class="source-line-no">074</span><span id="line-74"></span>
<span class="source-line-no">075</span><span id="line-75">            final int totalRead;</span>
<span class="source-line-no">076</span><span id="line-76">            if (entry.isSparse()) {</span>
<span class="source-line-no">077</span><span id="line-77">                totalRead = readSparse(entryOffset, buf, buf.limit());</span>
<span class="source-line-no">078</span><span id="line-78">            } else {</span>
<span class="source-line-no">079</span><span id="line-79">                totalRead = readArchive(pos, buf);</span>
<span class="source-line-no">080</span><span id="line-80">            }</span>
<span class="source-line-no">081</span><span id="line-81"></span>
<span class="source-line-no">082</span><span id="line-82">            if (totalRead == -1) {</span>
<span class="source-line-no">083</span><span id="line-83">                if (buf.array().length &gt; 0) {</span>
<span class="source-line-no">084</span><span id="line-84">                    throw new IOException("Truncated TAR archive");</span>
<span class="source-line-no">085</span><span id="line-85">                }</span>
<span class="source-line-no">086</span><span id="line-86">                setAtEOF(true);</span>
<span class="source-line-no">087</span><span id="line-87">            } else {</span>
<span class="source-line-no">088</span><span id="line-88">                entryOffset += totalRead;</span>
<span class="source-line-no">089</span><span id="line-89">                buf.flip();</span>
<span class="source-line-no">090</span><span id="line-90">            }</span>
<span class="source-line-no">091</span><span id="line-91">            return totalRead;</span>
<span class="source-line-no">092</span><span id="line-92">        }</span>
<span class="source-line-no">093</span><span id="line-93"></span>
<span class="source-line-no">094</span><span id="line-94">        private int readArchive(final long pos, final ByteBuffer buf) throws IOException {</span>
<span class="source-line-no">095</span><span id="line-95">            channel.position(pos);</span>
<span class="source-line-no">096</span><span id="line-96">            return channel.read(buf);</span>
<span class="source-line-no">097</span><span id="line-97">        }</span>
<span class="source-line-no">098</span><span id="line-98"></span>
<span class="source-line-no">099</span><span id="line-99">        private int readSparse(final long pos, final ByteBuffer buf, final int numToRead) throws IOException {</span>
<span class="source-line-no">100</span><span id="line-100">            // if there are no actual input streams, just read from the original archive</span>
<span class="source-line-no">101</span><span id="line-101">            final List&lt;InputStream&gt; entrySparseInputStreams = sparseInputStreams.get(entry.getName());</span>
<span class="source-line-no">102</span><span id="line-102">            if (entrySparseInputStreams == null || entrySparseInputStreams.isEmpty()) {</span>
<span class="source-line-no">103</span><span id="line-103">                return readArchive(entry.getDataOffset() + pos, buf);</span>
<span class="source-line-no">104</span><span id="line-104">            }</span>
<span class="source-line-no">105</span><span id="line-105"></span>
<span class="source-line-no">106</span><span id="line-106">            if (currentSparseInputStreamIndex &gt;= entrySparseInputStreams.size()) {</span>
<span class="source-line-no">107</span><span id="line-107">                return -1;</span>
<span class="source-line-no">108</span><span id="line-108">            }</span>
<span class="source-line-no">109</span><span id="line-109"></span>
<span class="source-line-no">110</span><span id="line-110">            final InputStream currentInputStream = entrySparseInputStreams.get(currentSparseInputStreamIndex);</span>
<span class="source-line-no">111</span><span id="line-111">            final byte[] bufArray = new byte[numToRead];</span>
<span class="source-line-no">112</span><span id="line-112">            final int readLen = currentInputStream.read(bufArray);</span>
<span class="source-line-no">113</span><span id="line-113">            if (readLen != -1) {</span>
<span class="source-line-no">114</span><span id="line-114">                buf.put(bufArray, 0, readLen);</span>
<span class="source-line-no">115</span><span id="line-115">            }</span>
<span class="source-line-no">116</span><span id="line-116"></span>
<span class="source-line-no">117</span><span id="line-117">            // if the current input stream is the last input stream,</span>
<span class="source-line-no">118</span><span id="line-118">            // just return the number of bytes read from current input stream</span>
<span class="source-line-no">119</span><span id="line-119">            if (currentSparseInputStreamIndex == entrySparseInputStreams.size() - 1) {</span>
<span class="source-line-no">120</span><span id="line-120">                return readLen;</span>
<span class="source-line-no">121</span><span id="line-121">            }</span>
<span class="source-line-no">122</span><span id="line-122"></span>
<span class="source-line-no">123</span><span id="line-123">            // if EOF of current input stream is meet, open a new input stream and recursively call read</span>
<span class="source-line-no">124</span><span id="line-124">            if (readLen == -1) {</span>
<span class="source-line-no">125</span><span id="line-125">                currentSparseInputStreamIndex++;</span>
<span class="source-line-no">126</span><span id="line-126">                return readSparse(pos, buf, numToRead);</span>
<span class="source-line-no">127</span><span id="line-127">            }</span>
<span class="source-line-no">128</span><span id="line-128"></span>
<span class="source-line-no">129</span><span id="line-129">            // if the rest data of current input stream is not long enough, open a new input stream</span>
<span class="source-line-no">130</span><span id="line-130">            // and recursively call read</span>
<span class="source-line-no">131</span><span id="line-131">            if (readLen &lt; numToRead) {</span>
<span class="source-line-no">132</span><span id="line-132">                currentSparseInputStreamIndex++;</span>
<span class="source-line-no">133</span><span id="line-133">                final int readLenOfNext = readSparse(pos + readLen, buf, numToRead - readLen);</span>
<span class="source-line-no">134</span><span id="line-134">                if (readLenOfNext == -1) {</span>
<span class="source-line-no">135</span><span id="line-135">                    return readLen;</span>
<span class="source-line-no">136</span><span id="line-136">                }</span>
<span class="source-line-no">137</span><span id="line-137"></span>
<span class="source-line-no">138</span><span id="line-138">                return readLen + readLenOfNext;</span>
<span class="source-line-no">139</span><span id="line-139">            }</span>
<span class="source-line-no">140</span><span id="line-140"></span>
<span class="source-line-no">141</span><span id="line-141">            // if the rest data of current input stream is enough(which means readLen == len), just return readLen</span>
<span class="source-line-no">142</span><span id="line-142">            return readLen;</span>
<span class="source-line-no">143</span><span id="line-143">        }</span>
<span class="source-line-no">144</span><span id="line-144">    }</span>
<span class="source-line-no">145</span><span id="line-145"></span>
<span class="source-line-no">146</span><span id="line-146">    private static final int SMALL_BUFFER_SIZE = 256;</span>
<span class="source-line-no">147</span><span id="line-147"></span>
<span class="source-line-no">148</span><span id="line-148">    private final byte[] smallBuf = new byte[SMALL_BUFFER_SIZE];</span>
<span class="source-line-no">149</span><span id="line-149"></span>
<span class="source-line-no">150</span><span id="line-150">    private final SeekableByteChannel archive;</span>
<span class="source-line-no">151</span><span id="line-151"></span>
<span class="source-line-no">152</span><span id="line-152">    /**</span>
<span class="source-line-no">153</span><span id="line-153">     * The encoding of the tar file</span>
<span class="source-line-no">154</span><span id="line-154">     */</span>
<span class="source-line-no">155</span><span id="line-155">    private final ZipEncoding zipEncoding;</span>
<span class="source-line-no">156</span><span id="line-156"></span>
<span class="source-line-no">157</span><span id="line-157">    private final LinkedList&lt;TarArchiveEntry&gt; entries = new LinkedList&lt;&gt;();</span>
<span class="source-line-no">158</span><span id="line-158"></span>
<span class="source-line-no">159</span><span id="line-159">    private final int blockSize;</span>
<span class="source-line-no">160</span><span id="line-160"></span>
<span class="source-line-no">161</span><span id="line-161">    private final boolean lenient;</span>
<span class="source-line-no">162</span><span id="line-162"></span>
<span class="source-line-no">163</span><span id="line-163">    private final int recordSize;</span>
<span class="source-line-no">164</span><span id="line-164"></span>
<span class="source-line-no">165</span><span id="line-165">    private final ByteBuffer recordBuffer;</span>
<span class="source-line-no">166</span><span id="line-166"></span>
<span class="source-line-no">167</span><span id="line-167">    // the global sparse headers, this is only used in PAX Format 0.X</span>
<span class="source-line-no">168</span><span id="line-168">    private final List&lt;TarArchiveStructSparse&gt; globalSparseHeaders = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">169</span><span id="line-169"></span>
<span class="source-line-no">170</span><span id="line-170">    private boolean hasHitEOF;</span>
<span class="source-line-no">171</span><span id="line-171"></span>
<span class="source-line-no">172</span><span id="line-172">    /**</span>
<span class="source-line-no">173</span><span id="line-173">     * The meta-data about the current entry</span>
<span class="source-line-no">174</span><span id="line-174">     */</span>
<span class="source-line-no">175</span><span id="line-175">    private TarArchiveEntry currEntry;</span>
<span class="source-line-no">176</span><span id="line-176"></span>
<span class="source-line-no">177</span><span id="line-177">    // the global PAX header</span>
<span class="source-line-no">178</span><span id="line-178">    private Map&lt;String, String&gt; globalPaxHeaders = new HashMap&lt;&gt;();</span>
<span class="source-line-no">179</span><span id="line-179"></span>
<span class="source-line-no">180</span><span id="line-180">    private final Map&lt;String, List&lt;InputStream&gt;&gt; sparseInputStreams = new HashMap&lt;&gt;();</span>
<span class="source-line-no">181</span><span id="line-181"></span>
<span class="source-line-no">182</span><span id="line-182">    /**</span>
<span class="source-line-no">183</span><span id="line-183">     * Constructor for TarFile.</span>
<span class="source-line-no">184</span><span id="line-184">     *</span>
<span class="source-line-no">185</span><span id="line-185">     * @param content the content to use</span>
<span class="source-line-no">186</span><span id="line-186">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">187</span><span id="line-187">     */</span>
<span class="source-line-no">188</span><span id="line-188">    public TarFile(final byte[] content) throws IOException {</span>
<span class="source-line-no">189</span><span id="line-189">        this(new SeekableInMemoryByteChannel(content));</span>
<span class="source-line-no">190</span><span id="line-190">    }</span>
<span class="source-line-no">191</span><span id="line-191"></span>
<span class="source-line-no">192</span><span id="line-192">    /**</span>
<span class="source-line-no">193</span><span id="line-193">     * Constructor for TarFile.</span>
<span class="source-line-no">194</span><span id="line-194">     *</span>
<span class="source-line-no">195</span><span id="line-195">     * @param content the content to use</span>
<span class="source-line-no">196</span><span id="line-196">     * @param lenient when set to true illegal values for group/userid, mode, device numbers and timestamp will be ignored and the fields set to</span>
<span class="source-line-no">197</span><span id="line-197">     *                {@link TarArchiveEntry#UNKNOWN}. When set to false such illegal fields cause an exception instead.</span>
<span class="source-line-no">198</span><span id="line-198">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">199</span><span id="line-199">     */</span>
<span class="source-line-no">200</span><span id="line-200">    public TarFile(final byte[] content, final boolean lenient) throws IOException {</span>
<span class="source-line-no">201</span><span id="line-201">        this(new SeekableInMemoryByteChannel(content), TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, null, lenient);</span>
<span class="source-line-no">202</span><span id="line-202">    }</span>
<span class="source-line-no">203</span><span id="line-203"></span>
<span class="source-line-no">204</span><span id="line-204">    /**</span>
<span class="source-line-no">205</span><span id="line-205">     * Constructor for TarFile.</span>
<span class="source-line-no">206</span><span id="line-206">     *</span>
<span class="source-line-no">207</span><span id="line-207">     * @param content  the content to use</span>
<span class="source-line-no">208</span><span id="line-208">     * @param encoding the encoding to use</span>
<span class="source-line-no">209</span><span id="line-209">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">210</span><span id="line-210">     */</span>
<span class="source-line-no">211</span><span id="line-211">    public TarFile(final byte[] content, final String encoding) throws IOException {</span>
<span class="source-line-no">212</span><span id="line-212">        this(new SeekableInMemoryByteChannel(content), TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, encoding, false);</span>
<span class="source-line-no">213</span><span id="line-213">    }</span>
<span class="source-line-no">214</span><span id="line-214"></span>
<span class="source-line-no">215</span><span id="line-215">    /**</span>
<span class="source-line-no">216</span><span id="line-216">     * Constructor for TarFile.</span>
<span class="source-line-no">217</span><span id="line-217">     *</span>
<span class="source-line-no">218</span><span id="line-218">     * @param archive the file of the archive to use</span>
<span class="source-line-no">219</span><span id="line-219">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">220</span><span id="line-220">     */</span>
<span class="source-line-no">221</span><span id="line-221">    public TarFile(final File archive) throws IOException {</span>
<span class="source-line-no">222</span><span id="line-222">        this(archive.toPath());</span>
<span class="source-line-no">223</span><span id="line-223">    }</span>
<span class="source-line-no">224</span><span id="line-224"></span>
<span class="source-line-no">225</span><span id="line-225">    /**</span>
<span class="source-line-no">226</span><span id="line-226">     * Constructor for TarFile.</span>
<span class="source-line-no">227</span><span id="line-227">     *</span>
<span class="source-line-no">228</span><span id="line-228">     * @param archive the file of the archive to use</span>
<span class="source-line-no">229</span><span id="line-229">     * @param lenient when set to true illegal values for group/userid, mode, device numbers and timestamp will be ignored and the fields set to</span>
<span class="source-line-no">230</span><span id="line-230">     *                {@link TarArchiveEntry#UNKNOWN}. When set to false such illegal fields cause an exception instead.</span>
<span class="source-line-no">231</span><span id="line-231">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">232</span><span id="line-232">     */</span>
<span class="source-line-no">233</span><span id="line-233">    public TarFile(final File archive, final boolean lenient) throws IOException {</span>
<span class="source-line-no">234</span><span id="line-234">        this(archive.toPath(), lenient);</span>
<span class="source-line-no">235</span><span id="line-235">    }</span>
<span class="source-line-no">236</span><span id="line-236"></span>
<span class="source-line-no">237</span><span id="line-237">    /**</span>
<span class="source-line-no">238</span><span id="line-238">     * Constructor for TarFile.</span>
<span class="source-line-no">239</span><span id="line-239">     *</span>
<span class="source-line-no">240</span><span id="line-240">     * @param archive  the file of the archive to use</span>
<span class="source-line-no">241</span><span id="line-241">     * @param encoding the encoding to use</span>
<span class="source-line-no">242</span><span id="line-242">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">243</span><span id="line-243">     */</span>
<span class="source-line-no">244</span><span id="line-244">    public TarFile(final File archive, final String encoding) throws IOException {</span>
<span class="source-line-no">245</span><span id="line-245">        this(archive.toPath(), encoding);</span>
<span class="source-line-no">246</span><span id="line-246">    }</span>
<span class="source-line-no">247</span><span id="line-247"></span>
<span class="source-line-no">248</span><span id="line-248">    /**</span>
<span class="source-line-no">249</span><span id="line-249">     * Constructor for TarFile.</span>
<span class="source-line-no">250</span><span id="line-250">     *</span>
<span class="source-line-no">251</span><span id="line-251">     * @param archivePath the path of the archive to use</span>
<span class="source-line-no">252</span><span id="line-252">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">253</span><span id="line-253">     */</span>
<span class="source-line-no">254</span><span id="line-254">    public TarFile(final Path archivePath) throws IOException {</span>
<span class="source-line-no">255</span><span id="line-255">        this(Files.newByteChannel(archivePath), TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, null, false);</span>
<span class="source-line-no">256</span><span id="line-256">    }</span>
<span class="source-line-no">257</span><span id="line-257"></span>
<span class="source-line-no">258</span><span id="line-258">    /**</span>
<span class="source-line-no">259</span><span id="line-259">     * Constructor for TarFile.</span>
<span class="source-line-no">260</span><span id="line-260">     *</span>
<span class="source-line-no">261</span><span id="line-261">     * @param archivePath the path of the archive to use</span>
<span class="source-line-no">262</span><span id="line-262">     * @param lenient     when set to true illegal values for group/userid, mode, device numbers and timestamp will be ignored and the fields set to</span>
<span class="source-line-no">263</span><span id="line-263">     *                    {@link TarArchiveEntry#UNKNOWN}. When set to false such illegal fields cause an exception instead.</span>
<span class="source-line-no">264</span><span id="line-264">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">265</span><span id="line-265">     */</span>
<span class="source-line-no">266</span><span id="line-266">    public TarFile(final Path archivePath, final boolean lenient) throws IOException {</span>
<span class="source-line-no">267</span><span id="line-267">        this(Files.newByteChannel(archivePath), TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, null, lenient);</span>
<span class="source-line-no">268</span><span id="line-268">    }</span>
<span class="source-line-no">269</span><span id="line-269"></span>
<span class="source-line-no">270</span><span id="line-270">    /**</span>
<span class="source-line-no">271</span><span id="line-271">     * Constructor for TarFile.</span>
<span class="source-line-no">272</span><span id="line-272">     *</span>
<span class="source-line-no">273</span><span id="line-273">     * @param archivePath the path of the archive to use</span>
<span class="source-line-no">274</span><span id="line-274">     * @param encoding    the encoding to use</span>
<span class="source-line-no">275</span><span id="line-275">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">276</span><span id="line-276">     */</span>
<span class="source-line-no">277</span><span id="line-277">    public TarFile(final Path archivePath, final String encoding) throws IOException {</span>
<span class="source-line-no">278</span><span id="line-278">        this(Files.newByteChannel(archivePath), TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, encoding, false);</span>
<span class="source-line-no">279</span><span id="line-279">    }</span>
<span class="source-line-no">280</span><span id="line-280"></span>
<span class="source-line-no">281</span><span id="line-281">    /**</span>
<span class="source-line-no">282</span><span id="line-282">     * Constructor for TarFile.</span>
<span class="source-line-no">283</span><span id="line-283">     *</span>
<span class="source-line-no">284</span><span id="line-284">     * @param content the content to use</span>
<span class="source-line-no">285</span><span id="line-285">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">286</span><span id="line-286">     */</span>
<span class="source-line-no">287</span><span id="line-287">    public TarFile(final SeekableByteChannel content) throws IOException {</span>
<span class="source-line-no">288</span><span id="line-288">        this(content, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, null, false);</span>
<span class="source-line-no">289</span><span id="line-289">    }</span>
<span class="source-line-no">290</span><span id="line-290"></span>
<span class="source-line-no">291</span><span id="line-291">    /**</span>
<span class="source-line-no">292</span><span id="line-292">     * Constructor for TarFile.</span>
<span class="source-line-no">293</span><span id="line-293">     *</span>
<span class="source-line-no">294</span><span id="line-294">     * @param archive    the seekable byte channel to use</span>
<span class="source-line-no">295</span><span id="line-295">     * @param blockSize  the blocks size to use</span>
<span class="source-line-no">296</span><span id="line-296">     * @param recordSize the record size to use</span>
<span class="source-line-no">297</span><span id="line-297">     * @param encoding   the encoding to use</span>
<span class="source-line-no">298</span><span id="line-298">     * @param lenient    when set to true illegal values for group/userid, mode, device numbers and timestamp will be ignored and the fields set to</span>
<span class="source-line-no">299</span><span id="line-299">     *                   {@link TarArchiveEntry#UNKNOWN}. When set to false such illegal fields cause an exception instead.</span>
<span class="source-line-no">300</span><span id="line-300">     * @throws IOException when reading the tar archive fails</span>
<span class="source-line-no">301</span><span id="line-301">     */</span>
<span class="source-line-no">302</span><span id="line-302">    public TarFile(final SeekableByteChannel archive, final int blockSize, final int recordSize, final String encoding, final boolean lenient)</span>
<span class="source-line-no">303</span><span id="line-303">            throws IOException {</span>
<span class="source-line-no">304</span><span id="line-304">        this.archive = archive;</span>
<span class="source-line-no">305</span><span id="line-305">        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);</span>
<span class="source-line-no">306</span><span id="line-306">        this.recordSize = recordSize;</span>
<span class="source-line-no">307</span><span id="line-307">        this.recordBuffer = ByteBuffer.allocate(this.recordSize);</span>
<span class="source-line-no">308</span><span id="line-308">        this.blockSize = blockSize;</span>
<span class="source-line-no">309</span><span id="line-309">        this.lenient = lenient;</span>
<span class="source-line-no">310</span><span id="line-310"></span>
<span class="source-line-no">311</span><span id="line-311">        TarArchiveEntry entry;</span>
<span class="source-line-no">312</span><span id="line-312">        while ((entry = getNextTarEntry()) != null) {</span>
<span class="source-line-no">313</span><span id="line-313">            entries.add(entry);</span>
<span class="source-line-no">314</span><span id="line-314">        }</span>
<span class="source-line-no">315</span><span id="line-315">    }</span>
<span class="source-line-no">316</span><span id="line-316"></span>
<span class="source-line-no">317</span><span id="line-317">    /**</span>
<span class="source-line-no">318</span><span id="line-318">     * Update the current entry with the read pax headers</span>
<span class="source-line-no">319</span><span id="line-319">     *</span>
<span class="source-line-no">320</span><span id="line-320">     * @param headers       Headers read from the pax header</span>
<span class="source-line-no">321</span><span id="line-321">     * @param sparseHeaders Sparse headers read from pax header</span>
<span class="source-line-no">322</span><span id="line-322">     */</span>
<span class="source-line-no">323</span><span id="line-323">    private void applyPaxHeadersToCurrentEntry(final Map&lt;String, String&gt; headers, final List&lt;TarArchiveStructSparse&gt; sparseHeaders) throws IOException {</span>
<span class="source-line-no">324</span><span id="line-324">        currEntry.updateEntryFromPaxHeaders(headers);</span>
<span class="source-line-no">325</span><span id="line-325">        currEntry.setSparseHeaders(sparseHeaders);</span>
<span class="source-line-no">326</span><span id="line-326">    }</span>
<span class="source-line-no">327</span><span id="line-327"></span>
<span class="source-line-no">328</span><span id="line-328">    /**</span>
<span class="source-line-no">329</span><span id="line-329">     * Build the input streams consisting of all-zero input streams and non-zero input streams. When reading from the non-zero input streams, the data is</span>
<span class="source-line-no">330</span><span id="line-330">     * actually read from the original input stream. The size of each input stream is introduced by the sparse headers.</span>
<span class="source-line-no">331</span><span id="line-331">     *</span>
<span class="source-line-no">332</span><span id="line-332">     * @implNote Some all-zero input streams and non-zero input streams have the size of 0. We DO NOT store the 0 size input streams because they are</span>
<span class="source-line-no">333</span><span id="line-333">     *           meaningless.</span>
<span class="source-line-no">334</span><span id="line-334">     */</span>
<span class="source-line-no">335</span><span id="line-335">    private void buildSparseInputStreams() throws IOException {</span>
<span class="source-line-no">336</span><span id="line-336">        final List&lt;InputStream&gt; streams = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">337</span><span id="line-337"></span>
<span class="source-line-no">338</span><span id="line-338">        final List&lt;TarArchiveStructSparse&gt; sparseHeaders = currEntry.getOrderedSparseHeaders();</span>
<span class="source-line-no">339</span><span id="line-339"></span>
<span class="source-line-no">340</span><span id="line-340">        // Stream doesn't need to be closed at all as it doesn't use any resources</span>
<span class="source-line-no">341</span><span id="line-341">        final InputStream zeroInputStream = new TarArchiveSparseZeroInputStream(); // NOSONAR</span>
<span class="source-line-no">342</span><span id="line-342">        // logical offset into the extracted entry</span>
<span class="source-line-no">343</span><span id="line-343">        long offset = 0;</span>
<span class="source-line-no">344</span><span id="line-344">        long numberOfZeroBytesInSparseEntry = 0;</span>
<span class="source-line-no">345</span><span id="line-345">        for (final TarArchiveStructSparse sparseHeader : sparseHeaders) {</span>
<span class="source-line-no">346</span><span id="line-346">            final long zeroBlockSize = sparseHeader.getOffset() - offset;</span>
<span class="source-line-no">347</span><span id="line-347">            if (zeroBlockSize &lt; 0) {</span>
<span class="source-line-no">348</span><span id="line-348">                // sparse header says to move backwards inside the extracted entry</span>
<span class="source-line-no">349</span><span id="line-349">                throw new IOException("Corrupted struct sparse detected");</span>
<span class="source-line-no">350</span><span id="line-350">            }</span>
<span class="source-line-no">351</span><span id="line-351"></span>
<span class="source-line-no">352</span><span id="line-352">            // only store the zero block if it is not empty</span>
<span class="source-line-no">353</span><span id="line-353">            if (zeroBlockSize &gt; 0) {</span>
<span class="source-line-no">354</span><span id="line-354">                streams.add(new BoundedInputStream(zeroInputStream, zeroBlockSize));</span>
<span class="source-line-no">355</span><span id="line-355">                numberOfZeroBytesInSparseEntry += zeroBlockSize;</span>
<span class="source-line-no">356</span><span id="line-356">            }</span>
<span class="source-line-no">357</span><span id="line-357"></span>
<span class="source-line-no">358</span><span id="line-358">            // only store the input streams with non-zero size</span>
<span class="source-line-no">359</span><span id="line-359">            if (sparseHeader.getNumbytes() &gt; 0) {</span>
<span class="source-line-no">360</span><span id="line-360">                final long start = currEntry.getDataOffset() + sparseHeader.getOffset() - numberOfZeroBytesInSparseEntry;</span>
<span class="source-line-no">361</span><span id="line-361">                if (start + sparseHeader.getNumbytes() &lt; start) {</span>
<span class="source-line-no">362</span><span id="line-362">                    // possible integer overflow</span>
<span class="source-line-no">363</span><span id="line-363">                    throw new IOException("Unreadable TAR archive, sparse block offset or length too big");</span>
<span class="source-line-no">364</span><span id="line-364">                }</span>
<span class="source-line-no">365</span><span id="line-365">                streams.add(new BoundedSeekableByteChannelInputStream(start, sparseHeader.getNumbytes(), archive));</span>
<span class="source-line-no">366</span><span id="line-366">            }</span>
<span class="source-line-no">367</span><span id="line-367"></span>
<span class="source-line-no">368</span><span id="line-368">            offset = sparseHeader.getOffset() + sparseHeader.getNumbytes();</span>
<span class="source-line-no">369</span><span id="line-369">        }</span>
<span class="source-line-no">370</span><span id="line-370"></span>
<span class="source-line-no">371</span><span id="line-371">        sparseInputStreams.put(currEntry.getName(), streams);</span>
<span class="source-line-no">372</span><span id="line-372">    }</span>
<span class="source-line-no">373</span><span id="line-373"></span>
<span class="source-line-no">374</span><span id="line-374">    @Override</span>
<span class="source-line-no">375</span><span id="line-375">    public void close() throws IOException {</span>
<span class="source-line-no">376</span><span id="line-376">        archive.close();</span>
<span class="source-line-no">377</span><span id="line-377">    }</span>
<span class="source-line-no">378</span><span id="line-378"></span>
<span class="source-line-no">379</span><span id="line-379">    /**</span>
<span class="source-line-no">380</span><span id="line-380">     * This method is invoked once the end of the archive is hit, it tries to consume the remaining bytes under the assumption that the tool creating this</span>
<span class="source-line-no">381</span><span id="line-381">     * archive has padded the last block.</span>
<span class="source-line-no">382</span><span id="line-382">     */</span>
<span class="source-line-no">383</span><span id="line-383">    private void consumeRemainderOfLastBlock() throws IOException {</span>
<span class="source-line-no">384</span><span id="line-384">        final long bytesReadOfLastBlock = archive.position() % blockSize;</span>
<span class="source-line-no">385</span><span id="line-385">        if (bytesReadOfLastBlock &gt; 0) {</span>
<span class="source-line-no">386</span><span id="line-386">            repositionForwardBy(blockSize - bytesReadOfLastBlock);</span>
<span class="source-line-no">387</span><span id="line-387">        }</span>
<span class="source-line-no">388</span><span id="line-388">    }</span>
<span class="source-line-no">389</span><span id="line-389"></span>
<span class="source-line-no">390</span><span id="line-390">    /**</span>
<span class="source-line-no">391</span><span id="line-391">     * Gets all TAR Archive Entries from the TarFile</span>
<span class="source-line-no">392</span><span id="line-392">     *</span>
<span class="source-line-no">393</span><span id="line-393">     * @return All entries from the tar file</span>
<span class="source-line-no">394</span><span id="line-394">     */</span>
<span class="source-line-no">395</span><span id="line-395">    public List&lt;TarArchiveEntry&gt; getEntries() {</span>
<span class="source-line-no">396</span><span id="line-396">        return new ArrayList&lt;&gt;(entries);</span>
<span class="source-line-no">397</span><span id="line-397">    }</span>
<span class="source-line-no">398</span><span id="line-398"></span>
<span class="source-line-no">399</span><span id="line-399">    /**</span>
<span class="source-line-no">400</span><span id="line-400">     * Gets the input stream for the provided Tar Archive Entry.</span>
<span class="source-line-no">401</span><span id="line-401">     *</span>
<span class="source-line-no">402</span><span id="line-402">     * @param entry Entry to get the input stream from</span>
<span class="source-line-no">403</span><span id="line-403">     * @return Input stream of the provided entry</span>
<span class="source-line-no">404</span><span id="line-404">     * @throws IOException Corrupted TAR archive. Can't read entry.</span>
<span class="source-line-no">405</span><span id="line-405">     */</span>
<span class="source-line-no">406</span><span id="line-406">    public InputStream getInputStream(final TarArchiveEntry entry) throws IOException {</span>
<span class="source-line-no">407</span><span id="line-407">        try {</span>
<span class="source-line-no">408</span><span id="line-408">            return new BoundedTarEntryInputStream(entry, archive);</span>
<span class="source-line-no">409</span><span id="line-409">        } catch (final RuntimeException ex) {</span>
<span class="source-line-no">410</span><span id="line-410">            throw new IOException("Corrupted TAR archive. Can't read entry", ex);</span>
<span class="source-line-no">411</span><span id="line-411">        }</span>
<span class="source-line-no">412</span><span id="line-412">    }</span>
<span class="source-line-no">413</span><span id="line-413"></span>
<span class="source-line-no">414</span><span id="line-414">    /**</span>
<span class="source-line-no">415</span><span id="line-415">     * Gets the next entry in this tar archive as long name data.</span>
<span class="source-line-no">416</span><span id="line-416">     *</span>
<span class="source-line-no">417</span><span id="line-417">     * @return The next entry in the archive as long name data, or null.</span>
<span class="source-line-no">418</span><span id="line-418">     * @throws IOException on error</span>
<span class="source-line-no">419</span><span id="line-419">     */</span>
<span class="source-line-no">420</span><span id="line-420">    private byte[] getLongNameData() throws IOException {</span>
<span class="source-line-no">421</span><span id="line-421">        final ByteArrayOutputStream longName = new ByteArrayOutputStream();</span>
<span class="source-line-no">422</span><span id="line-422">        int length;</span>
<span class="source-line-no">423</span><span id="line-423">        try (InputStream in = getInputStream(currEntry)) {</span>
<span class="source-line-no">424</span><span id="line-424">            while ((length = in.read(smallBuf)) &gt;= 0) {</span>
<span class="source-line-no">425</span><span id="line-425">                longName.write(smallBuf, 0, length);</span>
<span class="source-line-no">426</span><span id="line-426">            }</span>
<span class="source-line-no">427</span><span id="line-427">        }</span>
<span class="source-line-no">428</span><span id="line-428">        getNextTarEntry();</span>
<span class="source-line-no">429</span><span id="line-429">        if (currEntry == null) {</span>
<span class="source-line-no">430</span><span id="line-430">            // Bugzilla: 40334</span>
<span class="source-line-no">431</span><span id="line-431">            // Malformed tar file - long entry name not followed by entry</span>
<span class="source-line-no">432</span><span id="line-432">            return null;</span>
<span class="source-line-no">433</span><span id="line-433">        }</span>
<span class="source-line-no">434</span><span id="line-434">        byte[] longNameData = longName.toByteArray();</span>
<span class="source-line-no">435</span><span id="line-435">        // remove trailing null terminator(s)</span>
<span class="source-line-no">436</span><span id="line-436">        length = longNameData.length;</span>
<span class="source-line-no">437</span><span id="line-437">        while (length &gt; 0 &amp;&amp; longNameData[length - 1] == 0) {</span>
<span class="source-line-no">438</span><span id="line-438">            --length;</span>
<span class="source-line-no">439</span><span id="line-439">        }</span>
<span class="source-line-no">440</span><span id="line-440">        if (length != longNameData.length) {</span>
<span class="source-line-no">441</span><span id="line-441">            longNameData = Arrays.copyOf(longNameData, length);</span>
<span class="source-line-no">442</span><span id="line-442">        }</span>
<span class="source-line-no">443</span><span id="line-443">        return longNameData;</span>
<span class="source-line-no">444</span><span id="line-444">    }</span>
<span class="source-line-no">445</span><span id="line-445"></span>
<span class="source-line-no">446</span><span id="line-446">    /**</span>
<span class="source-line-no">447</span><span id="line-447">     * Gets the next entry in this tar archive. This will skip to the end of the current entry, if there is one, and place the position of the channel at the</span>
<span class="source-line-no">448</span><span id="line-448">     * header of the next entry, and read the header and instantiate a new TarEntry from the header bytes and return that entry. If there are no more entries in</span>
<span class="source-line-no">449</span><span id="line-449">     * the archive, null will be returned to indicate that the end of the archive has been reached.</span>
<span class="source-line-no">450</span><span id="line-450">     *</span>
<span class="source-line-no">451</span><span id="line-451">     * @return The next TarEntry in the archive, or null if there is no next entry.</span>
<span class="source-line-no">452</span><span id="line-452">     * @throws IOException when reading the next TarEntry fails</span>
<span class="source-line-no">453</span><span id="line-453">     */</span>
<span class="source-line-no">454</span><span id="line-454">    private TarArchiveEntry getNextTarEntry() throws IOException {</span>
<span class="source-line-no">455</span><span id="line-455">        if (isAtEOF()) {</span>
<span class="source-line-no">456</span><span id="line-456">            return null;</span>
<span class="source-line-no">457</span><span id="line-457">        }</span>
<span class="source-line-no">458</span><span id="line-458"></span>
<span class="source-line-no">459</span><span id="line-459">        if (currEntry != null) {</span>
<span class="source-line-no">460</span><span id="line-460">            // Skip to the end of the entry</span>
<span class="source-line-no">461</span><span id="line-461">            repositionForwardTo(currEntry.getDataOffset() + currEntry.getSize());</span>
<span class="source-line-no">462</span><span id="line-462">            throwExceptionIfPositionIsNotInArchive();</span>
<span class="source-line-no">463</span><span id="line-463">            skipRecordPadding();</span>
<span class="source-line-no">464</span><span id="line-464">        }</span>
<span class="source-line-no">465</span><span id="line-465"></span>
<span class="source-line-no">466</span><span id="line-466">        final ByteBuffer headerBuf = getRecord();</span>
<span class="source-line-no">467</span><span id="line-467">        if (null == headerBuf) {</span>
<span class="source-line-no">468</span><span id="line-468">            /* hit EOF */</span>
<span class="source-line-no">469</span><span id="line-469">            currEntry = null;</span>
<span class="source-line-no">470</span><span id="line-470">            return null;</span>
<span class="source-line-no">471</span><span id="line-471">        }</span>
<span class="source-line-no">472</span><span id="line-472"></span>
<span class="source-line-no">473</span><span id="line-473">        try {</span>
<span class="source-line-no">474</span><span id="line-474">            final long position = archive.position();</span>
<span class="source-line-no">475</span><span id="line-475">            currEntry = new TarArchiveEntry(globalPaxHeaders, headerBuf.array(), zipEncoding, lenient, position);</span>
<span class="source-line-no">476</span><span id="line-476">        } catch (final IllegalArgumentException e) {</span>
<span class="source-line-no">477</span><span id="line-477">            throw new IOException("Error detected parsing the header", e);</span>
<span class="source-line-no">478</span><span id="line-478">        }</span>
<span class="source-line-no">479</span><span id="line-479"></span>
<span class="source-line-no">480</span><span id="line-480">        if (currEntry.isGNULongLinkEntry()) {</span>
<span class="source-line-no">481</span><span id="line-481">            final byte[] longLinkData = getLongNameData();</span>
<span class="source-line-no">482</span><span id="line-482">            if (longLinkData == null) {</span>
<span class="source-line-no">483</span><span id="line-483">                // Bugzilla: 40334</span>
<span class="source-line-no">484</span><span id="line-484">                // Malformed tar file - long link entry name not followed by</span>
<span class="source-line-no">485</span><span id="line-485">                // entry</span>
<span class="source-line-no">486</span><span id="line-486">                return null;</span>
<span class="source-line-no">487</span><span id="line-487">            }</span>
<span class="source-line-no">488</span><span id="line-488">            currEntry.setLinkName(zipEncoding.decode(longLinkData));</span>
<span class="source-line-no">489</span><span id="line-489">        }</span>
<span class="source-line-no">490</span><span id="line-490"></span>
<span class="source-line-no">491</span><span id="line-491">        if (currEntry.isGNULongNameEntry()) {</span>
<span class="source-line-no">492</span><span id="line-492">            final byte[] longNameData = getLongNameData();</span>
<span class="source-line-no">493</span><span id="line-493">            if (longNameData == null) {</span>
<span class="source-line-no">494</span><span id="line-494">                // Bugzilla: 40334</span>
<span class="source-line-no">495</span><span id="line-495">                // Malformed tar file - long entry name not followed by</span>
<span class="source-line-no">496</span><span id="line-496">                // entry</span>
<span class="source-line-no">497</span><span id="line-497">                return null;</span>
<span class="source-line-no">498</span><span id="line-498">            }</span>
<span class="source-line-no">499</span><span id="line-499"></span>
<span class="source-line-no">500</span><span id="line-500">            // COMPRESS-509 : the name of directories should end with '/'</span>
<span class="source-line-no">501</span><span id="line-501">            final String name = zipEncoding.decode(longNameData);</span>
<span class="source-line-no">502</span><span id="line-502">            currEntry.setName(name);</span>
<span class="source-line-no">503</span><span id="line-503">            if (currEntry.isDirectory() &amp;&amp; !name.endsWith("/")) {</span>
<span class="source-line-no">504</span><span id="line-504">                currEntry.setName(name + "/");</span>
<span class="source-line-no">505</span><span id="line-505">            }</span>
<span class="source-line-no">506</span><span id="line-506">        }</span>
<span class="source-line-no">507</span><span id="line-507"></span>
<span class="source-line-no">508</span><span id="line-508">        if (currEntry.isGlobalPaxHeader()) { // Process Global Pax headers</span>
<span class="source-line-no">509</span><span id="line-509">            readGlobalPaxHeaders();</span>
<span class="source-line-no">510</span><span id="line-510">        }</span>
<span class="source-line-no">511</span><span id="line-511"></span>
<span class="source-line-no">512</span><span id="line-512">        try {</span>
<span class="source-line-no">513</span><span id="line-513">            if (currEntry.isPaxHeader()) { // Process Pax headers</span>
<span class="source-line-no">514</span><span id="line-514">                paxHeaders();</span>
<span class="source-line-no">515</span><span id="line-515">            } else if (!globalPaxHeaders.isEmpty()) {</span>
<span class="source-line-no">516</span><span id="line-516">                applyPaxHeadersToCurrentEntry(globalPaxHeaders, globalSparseHeaders);</span>
<span class="source-line-no">517</span><span id="line-517">            }</span>
<span class="source-line-no">518</span><span id="line-518">        } catch (final NumberFormatException e) {</span>
<span class="source-line-no">519</span><span id="line-519">            throw new IOException("Error detected parsing the pax header", e);</span>
<span class="source-line-no">520</span><span id="line-520">        }</span>
<span class="source-line-no">521</span><span id="line-521"></span>
<span class="source-line-no">522</span><span id="line-522">        if (currEntry.isOldGNUSparse()) { // Process sparse files</span>
<span class="source-line-no">523</span><span id="line-523">            readOldGNUSparse();</span>
<span class="source-line-no">524</span><span id="line-524">        }</span>
<span class="source-line-no">525</span><span id="line-525"></span>
<span class="source-line-no">526</span><span id="line-526">        return currEntry;</span>
<span class="source-line-no">527</span><span id="line-527">    }</span>
<span class="source-line-no">528</span><span id="line-528"></span>
<span class="source-line-no">529</span><span id="line-529">    /**</span>
<span class="source-line-no">530</span><span id="line-530">     * Gets the next record in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the</span>
<span class="source-line-no">531</span><span id="line-531">     * header of the next entry.</span>
<span class="source-line-no">532</span><span id="line-532">     *</span>
<span class="source-line-no">533</span><span id="line-533">     * &lt;p&gt;</span>
<span class="source-line-no">534</span><span id="line-534">     * If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached. At the same time the</span>
<span class="source-line-no">535</span><span id="line-535">     * {@code hasHitEOF} marker will be set to true.</span>
<span class="source-line-no">536</span><span id="line-536">     * &lt;/p&gt;</span>
<span class="source-line-no">537</span><span id="line-537">     *</span>
<span class="source-line-no">538</span><span id="line-538">     * @return The next TarEntry in the archive, or null if there is no next entry.</span>
<span class="source-line-no">539</span><span id="line-539">     * @throws IOException when reading the next TarEntry fails</span>
<span class="source-line-no">540</span><span id="line-540">     */</span>
<span class="source-line-no">541</span><span id="line-541">    private ByteBuffer getRecord() throws IOException {</span>
<span class="source-line-no">542</span><span id="line-542">        ByteBuffer headerBuf = readRecord();</span>
<span class="source-line-no">543</span><span id="line-543">        setAtEOF(isEOFRecord(headerBuf));</span>
<span class="source-line-no">544</span><span id="line-544">        if (isAtEOF() &amp;&amp; headerBuf != null) {</span>
<span class="source-line-no">545</span><span id="line-545">            // Consume rest</span>
<span class="source-line-no">546</span><span id="line-546">            tryToConsumeSecondEOFRecord();</span>
<span class="source-line-no">547</span><span id="line-547">            consumeRemainderOfLastBlock();</span>
<span class="source-line-no">548</span><span id="line-548">            headerBuf = null;</span>
<span class="source-line-no">549</span><span id="line-549">        }</span>
<span class="source-line-no">550</span><span id="line-550">        return headerBuf;</span>
<span class="source-line-no">551</span><span id="line-551">    }</span>
<span class="source-line-no">552</span><span id="line-552"></span>
<span class="source-line-no">553</span><span id="line-553">    protected final boolean isAtEOF() {</span>
<span class="source-line-no">554</span><span id="line-554">        return hasHitEOF;</span>
<span class="source-line-no">555</span><span id="line-555">    }</span>
<span class="source-line-no">556</span><span id="line-556"></span>
<span class="source-line-no">557</span><span id="line-557">    private boolean isDirectory() {</span>
<span class="source-line-no">558</span><span id="line-558">        return currEntry != null &amp;&amp; currEntry.isDirectory();</span>
<span class="source-line-no">559</span><span id="line-559">    }</span>
<span class="source-line-no">560</span><span id="line-560"></span>
<span class="source-line-no">561</span><span id="line-561">    private boolean isEOFRecord(final ByteBuffer headerBuf) {</span>
<span class="source-line-no">562</span><span id="line-562">        return headerBuf == null || ArchiveUtils.isArrayZero(headerBuf.array(), recordSize);</span>
<span class="source-line-no">563</span><span id="line-563">    }</span>
<span class="source-line-no">564</span><span id="line-564"></span>
<span class="source-line-no">565</span><span id="line-565">    /**</span>
<span class="source-line-no">566</span><span id="line-566">     * &lt;p&gt;</span>
<span class="source-line-no">567</span><span id="line-567">     * For PAX Format 0.0, the sparse headers(GNU.sparse.offset and GNU.sparse.numbytes) may appear multi times, and they look like:</span>
<span class="source-line-no">568</span><span id="line-568">     *</span>
<span class="source-line-no">569</span><span id="line-569">     * &lt;pre&gt;</span>
<span class="source-line-no">570</span><span id="line-570">     * GNU.sparse.size=size</span>
<span class="source-line-no">571</span><span id="line-571">     * GNU.sparse.numblocks=numblocks</span>
<span class="source-line-no">572</span><span id="line-572">     * repeat numblocks times</span>
<span class="source-line-no">573</span><span id="line-573">     *   GNU.sparse.offset=offset</span>
<span class="source-line-no">574</span><span id="line-574">     *   GNU.sparse.numbytes=numbytes</span>
<span class="source-line-no">575</span><span id="line-575">     * end repeat</span>
<span class="source-line-no">576</span><span id="line-576">     * &lt;/pre&gt;</span>
<span class="source-line-no">577</span><span id="line-577">     *</span>
<span class="source-line-no">578</span><span id="line-578">     * &lt;p&gt;</span>
<span class="source-line-no">579</span><span id="line-579">     * For PAX Format 0.1, the sparse headers are stored in a single variable : GNU.sparse.map</span>
<span class="source-line-no">580</span><span id="line-580">     *</span>
<span class="source-line-no">581</span><span id="line-581">     * &lt;pre&gt;</span>
<span class="source-line-no">582</span><span id="line-582">     * GNU.sparse.map</span>
<span class="source-line-no">583</span><span id="line-583">     *    Map of non-null data chunks. It is a string consisting of comma-separated values "offset,size[,offset-1,size-1...]"</span>
<span class="source-line-no">584</span><span id="line-584">     * &lt;/pre&gt;</span>
<span class="source-line-no">585</span><span id="line-585">     *</span>
<span class="source-line-no">586</span><span id="line-586">     * &lt;p&gt;</span>
<span class="source-line-no">587</span><span id="line-587">     * For PAX Format 1.X: &lt;br&gt;</span>
<span class="source-line-no">588</span><span id="line-588">     * The sparse map itself is stored in the file data block, preceding the actual file data. It consists of a series of decimal numbers delimited by newlines.</span>
<span class="source-line-no">589</span><span id="line-589">     * The map is padded with nulls to the nearest block boundary. The first number gives the number of entries in the map. Following are map entries, each one</span>
<span class="source-line-no">590</span><span id="line-590">     * consisting of two numbers giving the offset and size of the data block it describes.</span>
<span class="source-line-no">591</span><span id="line-591">     *</span>
<span class="source-line-no">592</span><span id="line-592">     * @throws IOException</span>
<span class="source-line-no">593</span><span id="line-593">     */</span>
<span class="source-line-no">594</span><span id="line-594">    private void paxHeaders() throws IOException {</span>
<span class="source-line-no">595</span><span id="line-595">        List&lt;TarArchiveStructSparse&gt; sparseHeaders = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">596</span><span id="line-596">        final Map&lt;String, String&gt; headers;</span>
<span class="source-line-no">597</span><span id="line-597">        try (InputStream input = getInputStream(currEntry)) {</span>
<span class="source-line-no">598</span><span id="line-598">            headers = TarUtils.parsePaxHeaders(input, sparseHeaders, globalPaxHeaders, currEntry.getSize());</span>
<span class="source-line-no">599</span><span id="line-599">        }</span>
<span class="source-line-no">600</span><span id="line-600"></span>
<span class="source-line-no">601</span><span id="line-601">        // for 0.1 PAX Headers</span>
<span class="source-line-no">602</span><span id="line-602">        if (headers.containsKey(TarGnuSparseKeys.MAP)) {</span>
<span class="source-line-no">603</span><span id="line-603">            sparseHeaders = new ArrayList&lt;&gt;(TarUtils.parseFromPAX01SparseHeaders(headers.get(TarGnuSparseKeys.MAP)));</span>
<span class="source-line-no">604</span><span id="line-604">        }</span>
<span class="source-line-no">605</span><span id="line-605">        getNextTarEntry(); // Get the actual file entry</span>
<span class="source-line-no">606</span><span id="line-606">        if (currEntry == null) {</span>
<span class="source-line-no">607</span><span id="line-607">            throw new IOException("premature end of tar archive. Didn't find any entry after PAX header.");</span>
<span class="source-line-no">608</span><span id="line-608">        }</span>
<span class="source-line-no">609</span><span id="line-609">        applyPaxHeadersToCurrentEntry(headers, sparseHeaders);</span>
<span class="source-line-no">610</span><span id="line-610"></span>
<span class="source-line-no">611</span><span id="line-611">        // for 1.0 PAX Format, the sparse map is stored in the file data block</span>
<span class="source-line-no">612</span><span id="line-612">        if (currEntry.isPaxGNU1XSparse()) {</span>
<span class="source-line-no">613</span><span id="line-613">            try (InputStream input = getInputStream(currEntry)) {</span>
<span class="source-line-no">614</span><span id="line-614">                sparseHeaders = TarUtils.parsePAX1XSparseHeaders(input, recordSize);</span>
<span class="source-line-no">615</span><span id="line-615">            }</span>
<span class="source-line-no">616</span><span id="line-616">            currEntry.setSparseHeaders(sparseHeaders);</span>
<span class="source-line-no">617</span><span id="line-617">            // data of the entry is after the pax gnu entry. So we need to update the data position once again</span>
<span class="source-line-no">618</span><span id="line-618">            currEntry.setDataOffset(currEntry.getDataOffset() + recordSize);</span>
<span class="source-line-no">619</span><span id="line-619">        }</span>
<span class="source-line-no">620</span><span id="line-620"></span>
<span class="source-line-no">621</span><span id="line-621">        // sparse headers are all done reading, we need to build</span>
<span class="source-line-no">622</span><span id="line-622">        // sparse input streams using these sparse headers</span>
<span class="source-line-no">623</span><span id="line-623">        buildSparseInputStreams();</span>
<span class="source-line-no">624</span><span id="line-624">    }</span>
<span class="source-line-no">625</span><span id="line-625"></span>
<span class="source-line-no">626</span><span id="line-626">    private void readGlobalPaxHeaders() throws IOException {</span>
<span class="source-line-no">627</span><span id="line-627">        try (InputStream input = getInputStream(currEntry)) {</span>
<span class="source-line-no">628</span><span id="line-628">            globalPaxHeaders = TarUtils.parsePaxHeaders(input, globalSparseHeaders, globalPaxHeaders, currEntry.getSize());</span>
<span class="source-line-no">629</span><span id="line-629">        }</span>
<span class="source-line-no">630</span><span id="line-630">        getNextTarEntry(); // Get the actual file entry</span>
<span class="source-line-no">631</span><span id="line-631"></span>
<span class="source-line-no">632</span><span id="line-632">        if (currEntry == null) {</span>
<span class="source-line-no">633</span><span id="line-633">            throw new IOException("Error detected parsing the pax header");</span>
<span class="source-line-no">634</span><span id="line-634">        }</span>
<span class="source-line-no">635</span><span id="line-635">    }</span>
<span class="source-line-no">636</span><span id="line-636"></span>
<span class="source-line-no">637</span><span id="line-637">    /**</span>
<span class="source-line-no">638</span><span id="line-638">     * Adds the sparse chunks from the current entry to the sparse chunks, including any additional sparse entries following the current entry.</span>
<span class="source-line-no">639</span><span id="line-639">     *</span>
<span class="source-line-no">640</span><span id="line-640">     * @throws IOException when reading the sparse entry fails</span>
<span class="source-line-no">641</span><span id="line-641">     */</span>
<span class="source-line-no">642</span><span id="line-642">    private void readOldGNUSparse() throws IOException {</span>
<span class="source-line-no">643</span><span id="line-643">        if (currEntry.isExtended()) {</span>
<span class="source-line-no">644</span><span id="line-644">            TarArchiveSparseEntry entry;</span>
<span class="source-line-no">645</span><span id="line-645">            do {</span>
<span class="source-line-no">646</span><span id="line-646">                final ByteBuffer headerBuf = getRecord();</span>
<span class="source-line-no">647</span><span id="line-647">                if (headerBuf == null) {</span>
<span class="source-line-no">648</span><span id="line-648">                    throw new IOException("premature end of tar archive. Didn't find extended_header after header with extended flag.");</span>
<span class="source-line-no">649</span><span id="line-649">                }</span>
<span class="source-line-no">650</span><span id="line-650">                entry = new TarArchiveSparseEntry(headerBuf.array());</span>
<span class="source-line-no">651</span><span id="line-651">                currEntry.getSparseHeaders().addAll(entry.getSparseHeaders());</span>
<span class="source-line-no">652</span><span id="line-652">                currEntry.setDataOffset(currEntry.getDataOffset() + recordSize);</span>
<span class="source-line-no">653</span><span id="line-653">            } while (entry.isExtended());</span>
<span class="source-line-no">654</span><span id="line-654">        }</span>
<span class="source-line-no">655</span><span id="line-655"></span>
<span class="source-line-no">656</span><span id="line-656">        // sparse headers are all done reading, we need to build</span>
<span class="source-line-no">657</span><span id="line-657">        // sparse input streams using these sparse headers</span>
<span class="source-line-no">658</span><span id="line-658">        buildSparseInputStreams();</span>
<span class="source-line-no">659</span><span id="line-659">    }</span>
<span class="source-line-no">660</span><span id="line-660"></span>
<span class="source-line-no">661</span><span id="line-661">    /**</span>
<span class="source-line-no">662</span><span id="line-662">     * Read a record from the input stream and return the data.</span>
<span class="source-line-no">663</span><span id="line-663">     *</span>
<span class="source-line-no">664</span><span id="line-664">     * @return The record data or null if EOF has been hit.</span>
<span class="source-line-no">665</span><span id="line-665">     * @throws IOException if reading from the archive fails</span>
<span class="source-line-no">666</span><span id="line-666">     */</span>
<span class="source-line-no">667</span><span id="line-667">    private ByteBuffer readRecord() throws IOException {</span>
<span class="source-line-no">668</span><span id="line-668">        recordBuffer.rewind();</span>
<span class="source-line-no">669</span><span id="line-669">        final int readNow = archive.read(recordBuffer);</span>
<span class="source-line-no">670</span><span id="line-670">        if (readNow != recordSize) {</span>
<span class="source-line-no">671</span><span id="line-671">            return null;</span>
<span class="source-line-no">672</span><span id="line-672">        }</span>
<span class="source-line-no">673</span><span id="line-673">        return recordBuffer;</span>
<span class="source-line-no">674</span><span id="line-674">    }</span>
<span class="source-line-no">675</span><span id="line-675"></span>
<span class="source-line-no">676</span><span id="line-676">    private void repositionForwardBy(final long offset) throws IOException {</span>
<span class="source-line-no">677</span><span id="line-677">        repositionForwardTo(archive.position() + offset);</span>
<span class="source-line-no">678</span><span id="line-678">    }</span>
<span class="source-line-no">679</span><span id="line-679"></span>
<span class="source-line-no">680</span><span id="line-680">    private void repositionForwardTo(final long newPosition) throws IOException {</span>
<span class="source-line-no">681</span><span id="line-681">        final long currPosition = archive.position();</span>
<span class="source-line-no">682</span><span id="line-682">        if (newPosition &lt; currPosition) {</span>
<span class="source-line-no">683</span><span id="line-683">            throw new IOException("trying to move backwards inside of the archive");</span>
<span class="source-line-no">684</span><span id="line-684">        }</span>
<span class="source-line-no">685</span><span id="line-685">        archive.position(newPosition);</span>
<span class="source-line-no">686</span><span id="line-686">    }</span>
<span class="source-line-no">687</span><span id="line-687"></span>
<span class="source-line-no">688</span><span id="line-688">    protected final void setAtEOF(final boolean b) {</span>
<span class="source-line-no">689</span><span id="line-689">        hasHitEOF = b;</span>
<span class="source-line-no">690</span><span id="line-690">    }</span>
<span class="source-line-no">691</span><span id="line-691"></span>
<span class="source-line-no">692</span><span id="line-692">    /**</span>
<span class="source-line-no">693</span><span id="line-693">     * The last record block should be written at the full size, so skip any additional space used to fill a record after an entry</span>
<span class="source-line-no">694</span><span id="line-694">     *</span>
<span class="source-line-no">695</span><span id="line-695">     * @throws IOException when skipping the padding of the record fails</span>
<span class="source-line-no">696</span><span id="line-696">     */</span>
<span class="source-line-no">697</span><span id="line-697">    private void skipRecordPadding() throws IOException {</span>
<span class="source-line-no">698</span><span id="line-698">        if (!isDirectory() &amp;&amp; currEntry.getSize() &gt; 0 &amp;&amp; currEntry.getSize() % recordSize != 0) {</span>
<span class="source-line-no">699</span><span id="line-699">            final long numRecords = currEntry.getSize() / recordSize + 1;</span>
<span class="source-line-no">700</span><span id="line-700">            final long padding = numRecords * recordSize - currEntry.getSize();</span>
<span class="source-line-no">701</span><span id="line-701">            repositionForwardBy(padding);</span>
<span class="source-line-no">702</span><span id="line-702">            throwExceptionIfPositionIsNotInArchive();</span>
<span class="source-line-no">703</span><span id="line-703">        }</span>
<span class="source-line-no">704</span><span id="line-704">    }</span>
<span class="source-line-no">705</span><span id="line-705"></span>
<span class="source-line-no">706</span><span id="line-706">    /**</span>
<span class="source-line-no">707</span><span id="line-707">     * Checks if the current position of the SeekableByteChannel is in the archive.</span>
<span class="source-line-no">708</span><span id="line-708">     *</span>
<span class="source-line-no">709</span><span id="line-709">     * @throws IOException If the position is not in the archive</span>
<span class="source-line-no">710</span><span id="line-710">     */</span>
<span class="source-line-no">711</span><span id="line-711">    private void throwExceptionIfPositionIsNotInArchive() throws IOException {</span>
<span class="source-line-no">712</span><span id="line-712">        if (archive.size() &lt; archive.position()) {</span>
<span class="source-line-no">713</span><span id="line-713">            throw new IOException("Truncated TAR archive");</span>
<span class="source-line-no">714</span><span id="line-714">        }</span>
<span class="source-line-no">715</span><span id="line-715">    }</span>
<span class="source-line-no">716</span><span id="line-716"></span>
<span class="source-line-no">717</span><span id="line-717">    /**</span>
<span class="source-line-no">718</span><span id="line-718">     * Tries to read the next record resetting the position in the archive if it is not an EOF record.</span>
<span class="source-line-no">719</span><span id="line-719">     *</span>
<span class="source-line-no">720</span><span id="line-720">     * &lt;p&gt;</span>
<span class="source-line-no">721</span><span id="line-721">     * This is meant to protect against cases where a tar implementation has written only one EOF record when two are expected. Actually this won't help since a</span>
<span class="source-line-no">722</span><span id="line-722">     * non-conforming implementation likely won't fill full blocks consisting of - by default - ten records either so we probably have already read beyond the</span>
<span class="source-line-no">723</span><span id="line-723">     * archive anyway.</span>
<span class="source-line-no">724</span><span id="line-724">     * &lt;/p&gt;</span>
<span class="source-line-no">725</span><span id="line-725">     *</span>
<span class="source-line-no">726</span><span id="line-726">     * @throws IOException if reading the record of resetting the position in the archive fails</span>
<span class="source-line-no">727</span><span id="line-727">     */</span>
<span class="source-line-no">728</span><span id="line-728">    private void tryToConsumeSecondEOFRecord() throws IOException {</span>
<span class="source-line-no">729</span><span id="line-729">        boolean shouldReset = true;</span>
<span class="source-line-no">730</span><span id="line-730">        try {</span>
<span class="source-line-no">731</span><span id="line-731">            shouldReset = !isEOFRecord(readRecord());</span>
<span class="source-line-no">732</span><span id="line-732">        } finally {</span>
<span class="source-line-no">733</span><span id="line-733">            if (shouldReset) {</span>
<span class="source-line-no">734</span><span id="line-734">                archive.position(archive.position() - recordSize);</span>
<span class="source-line-no">735</span><span id="line-735">            }</span>
<span class="source-line-no">736</span><span id="line-736">        }</span>
<span class="source-line-no">737</span><span id="line-737">    }</span>
<span class="source-line-no">738</span><span id="line-738">}</span>




























































</pre>
</div>
</main>
</body>
</html>
